# 前言

审批流是什么？

某件事情不能直接做（请假等），或某些数据不能直接生效，需要由业务人员针对该数据（表单）发起一个流程，领导或相关责任人审批通过后才可生效。

就像一千个观众眼中有一千个哈姆雷特，一千个人眼中也会对审批流有一千种看法。

每个人对审批流都有自己的理解，每个系统使用的审批流所需的操作和展现形式都会有所不同。

这篇文章仅阐述下我对审批流的看法。

# 1.概述

## 1.1核心思想

任务驱动，流程某次到某个节点时给该节点审批人发放一个任务，用户在界面上的审批操作需明确操作的是哪个任务

为什么要任务驱动？因为无法根据【用户、流程、节点】定位到一次具体的操作，可以参考以下几个场景

1.用户在一个流程中的多个节点需要审批

2.用户在一个流程中的同一个节点，作为不同的身份需要审批多次

3.用户在一个流程中的同一个节点，在不同的时机（比如流程退回后重新到达该节点）需要审批多次

## 1.2模块划分

1.设计态：管理员操作，流程模型设计、发布、导入导出、停用启用

2.运行态：实际用户操作，任务列表、流程列表、审批操作、流程历史数据追踪

为什么只能划分为两个模块？因为针对模块内的一处改动会对其他地方造成影响，模块内的一处feature可能需要其他地方来协助完成。

## 1.3实现方式

1.流程数量不定的，需支持在线设计的，灵活的，但不贴合业务的（中间件、独立服务、低代码平台）

2.流程数量固定的，可以无需支持在线设计，可针对业务定制化开发（与业务系统集成）

# 2.概念介绍

## 2.1什么是bpmn

业务流程模型和标记法（BPMN, Business Process Model and Notation）[译注1]是一套图形化表示法，用于以业务流程模型详细说明各种业务流程。

它最初由业务流程管理倡议组织（BPMI, Business Process Management Initiative）开发，名称为"Business Process Modeling Notation"，即“业务流程建模标记法”。BPMI于2005年与对象管理组织（OMG, Object Management Group）合并。2011年1月OMG发布2.0版本，同时改为现在的名称。

[https://zh.wikipedia.org/wiki/%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%A0%87%E8%AE%B0%E6%B3%95](https://zh.wikipedia.org/wiki/业务流程模型和标记法)

## 2.2基础节点

空开始节点：流程启动节点，无其他操作。

空结束节点：流程结束节点，无其他操作。

用户任务：流程到达该节点后，会根据规则给该该节点关联的审批人发放审批任务，流程会暂停不再继续流转，需要用户审批或操作后才能继续运转。

排他网关：排他网关后可跟随多个其他节点，在与其他节点间的顺序流上可配置条件，最终后续节点只有一个节点可执行。业务场景：如报销小于1000元仅需组长审批，大于等于1000元则需主管审批。

并行网关：并行网关前后都可跟随多个其他节点，在与其他节点间的顺序流上可配置条件，可有多个满足条件的节点同时运行。业务场景：如需两个不相关的部门同时审批。

顺序流：各节点间的连线，节点间通过顺序流关联在一起。

## 2.3数据定义

流程模型：用图的方式描述一个流程经过的所有节点、走向、条件及审批人。

流程定义：一个已发布的流程模型。流程模型和流程定义一般以一个key用作分组，同一个key下的流程模型和定义被定义为不同的版本。一般都是根据key发起流程，在发布一个新版本的流程定义后，新发起的流程都使用最新版本的流程定义，与此同时使用旧版本流程定义发起的流程并不会受到影响（依然走旧版本流程定义的逻辑）。

流程实例：每创建一个新的流程，就会产生一个新的流程实例。创建流程实例的方式可以是申请者提交表单发起流程，也可以是定时任务发起流程。

任务实例：审批流程中审批节点需用户操作后流程才能继续往后运转，用户针对任务进行操作。即一个节点有多个审批人时，就有多个任务。即一个流程、一次进入某流程节点、一个审批人可定义一个任务。

执行实例：流程引擎的一个动作，如进入到一个节点，如发放一个任务，被定义为一个执行实例。

流程变量：流程所需使用的数据。控制流程走向的条件，流程某个节点的审批人等都是流程变量。

## 2.4审批方式

多实例：流程在某个节点给多个用户发放审批任务。业务场景：某节点需要xx岗位审批，该岗位实际上有多人。

有了多实例的概念，由此引出以下审批方式：

1.会签（全票通过，比例通过）：多个审批人同时可以审批，多个审批人给出意见后节点通过。

2.或签：多个审批人同时可以审批，一个人审批后节点通过。

3.串签：单节点多审批人，前一个审批人审批通过后，后一个审批人才能继续审批。业务场景：连续多级上级审批，某流程需要从用户的主管开始审批，一直审批到最高领导，此时无法判断用户有几级上级。

## 2.5操作

流程操作 → 审批操作 → 业务操作

流程引擎底层是流程操作，审批流通用的是审批操作，贴合业务的是业务操作。

驱动流程运转的是流程操作，审批流对外暴露的公共通用能力是审批操作，为了更贴合业务定制化的是业务操作。

### 2.5.1流程操作

发起流程：创建一个新的流程实例，流程实例根据流程模型定义开始运转。

结束流程：流程实例状态标记为已结束，但不会删除，理论上不可再对该流程进行操作。

流程节点跳转：操作一个运行中的流程，从一个节点跳转到另一个节点。该跳转可以是根据规则（流程模型定义）来的正常跳转（流程正常流转），也可以是一次操作引发的特殊跳转。

完成任务：用户任务节点发放的任务被完成，可能会触发流程的推进（满足该节点的完成条件），也可能不会触发流程的推进（需要等待该节点其他用户操作）。

启用流程：将一个暂停的流程启用，可以重新操作流程。

挂起流程：将一个运行中的流程暂停，不可再操作该流程，但并不是结束，后续可以启用流程。

加签：流程中某多实例用户任务节点，新增一个审批任务。

减签：流程中某多实例用户任务节点，减少一个审批任务。

### 2.5.2审批操作

通过：针对运行中任务进行操作，将此任务标记为通过，并判断该流程是否可以往后续节点运转。

拒绝：针对运行中任务进行操作，将此任务标记为拒绝，并结束该流程。

驳回某节点：针对运行中任务进行操作，将此任务标记为驳回，将流程跳转至某已走过的节点。

撤回任务操作：针对已处理（已通过）任务进行操作，流程处于同节点时，重新生成新任务；流程处于其他节点时，将流程跳转至该任务所在节点。

撤回流程：（发起人）针对流程进行操作，结束该流程。

跳转：（管理员）针对流程进行操作，将运行中的流程跳转至选择的任意节点。

加签：针对流程进行操作，对流程某节点增加审批人。

前加签：针对任务进行操作，当前任务审批人选择前加签用户发放新任务并取消自己的任务，待前加签用户处理完任务后重新给当前任务审批人发放任务。

后加签：针对任务进行操作，当前任务审批人通过该任务后不结束该节点，并选择后加签用户发放新任务，待后加签用户处理完任务后才结束该节点。

转交（一对一）：针对任务进行操作，将原审批人的任务转交给新审批人。

转办（多对一）：针对流程进行操作，将流程中某个节点的任务全部取消，并新生成一个任务交由新审批人处理。

抄送：针对流程或任务进行操作，在发起流程或处理任务时对相关用户进行通知。

催办：（发起人）针对任务进行操作，对流程中运行中任务的审批人进行催办。

### 2.5.3业务操作

以租赁业务系统为例：

1.同意（投票）、有条件同意（投票）、退回（投票）：

业务场景：某个会签节点，所有人给出意见后该节点通过，下一节点审批人需要看到该节点审批人的操作。

所以该业务操作可映射成审批操作：通过，并记录相关操作的业务状态。

2.退回到发起人：

业务场景：发起人具有特殊含义，多数节点都进行该操作，而无需额外选择驳回节点。

所以该业务操作可映射成审批操作：驳回某节点-驳回发起人节点。

3.复议、重新投票：

业务场景：产品和客户觉得此处的审批操作（影响到审批历史里的操作记录）叫这个名字会让人比较容易理解。

但对流程来说实际上就是驳回到某个节点的操作，所以此处的操作依然可以映射成审批操作：驳回某节点。

## 2.6任务列表

一般任务列表就分为4个：我发起的、待办、已办、消息通知。

## 2.7流程状态、任务状态、业务状态

流程状态：运行中、已结束（已取消、审批通过、审批拒绝）

任务状态：运行中、已结束（通过、拒绝、转交、驳回、未处理自动结束（一般不显示））

业务状态：挂载在节点上，方便用户能更直观的感受出当前流程所处的阶段。如流程的前几个审批节点被定义为部门内审批，后续被定义为高管审批。

## 2.8其他

一个审批流除了提供操作、任务列表等功能外，还需提供如展示流程审批历史（操作记录）、展示流程图（标记流程运行情况）等功能。

# 3.审批流开发

## 3.1flowable框架

flowable是一个使用java编写的轻量级业务流程引擎。flowable流程引擎可用于部署BPMN 2.0流程定义（用于定义流程的行业XML标准）， 创建这些流程定义的流程实例，进行查询，访问运行中或历史的流程实例与相关数据，等等。

flowable本身是流程框架，其api不包含审批概念。基于flowable开发审批流即是调用框架api控制流程、任务、节点、数据的运转，在此基础上赋予审批的概念。

我设计的审批流二方包基于flowable框架（6.7.2版本）。

https://tkjohn.github.io/flowable-userguide/

https://github.com/flowable/flowable-engine



使用框架的好处：框架实现了解析bpmn xml的逻辑，并实现了流程运转的整套逻辑代码，其代码包含了bpmn规范中的大多数节点定义，而使用者只需要学习并使用其api就可快速的实现自己的流程逻辑。

使用框架的弊端：框架较重，有一定学习成本，且不太灵活（如加字段只能额外加表，无法在框架自身表上加字段）。框架出问题的时候只能想办法规避，修复的成本过高。框架本身不支持的底层功能我们较难扩展。

## 3.2审批本身逻辑的开发

其实在使用了flowable框架后，审批流本身逻辑的开发没什么好说的，基本上都是根据第二节所描述的审批相关操作概念封装审批操作方法，审批操作方法里会加上审批相关的逻辑（和一些业务逻辑），并记录一些我们自己系统所需的信息，实际上推动流程流转的都是调用的flowable框架提供的api。

这里值得一提的是扩展参数的实现方式。bpmn的xml本身定义的数据并不一定满足我们实际的需要（如某用户节点的审批人选取规则、某节点的时间选择（bpmn使用的时间是PT之类的完全不符合用户习惯的格式）），我们需要在此基础上再做扩展。此处使用的方式是针对每一个流程模型，额外有一个json去记录自定义扩展参数，此参数可针对模型进行数据扩展，也可针对模型中某个节点进行数据扩展（根据节点id）。

租赁系统使用的审批流代码及相关分支，有兴趣大家可以去看看

http://gitlab.zswl.cn:8888/zswl/flow/-/tree/dev/mithras-1.0.1

## 3.3与业务结合

审批流应作为一个独立的模块，（尽量）只在流程开始和结束的时候与业务有挂钩。

一个流程实例与业务数据挂钩的方式应该是流程实例持有一个业务数据的主键。对于业务数据来说，审批流应该（尽量）是一个黑盒，（尽量）不需要关注审批运行的过程，而只关注发起流程、流程结束。业务数据不应任何地方保存审批流相关的数据（如流程实例id、任务id等）。

用户在界面上审批时能明确定位到一个任务，用户的审批是针对任务，针对某个流程进行审批，而不是直接针对业务数据进行审批。

在菜单列表里审批流具有一个单独的菜单。在任务详情界面，审批相关模块应具有基本一致的操作，业务相关模块根据该任务所属的流程实例对应的流程模型对应的业务模块，渲染出对应的业务数据。



为什么要解耦？

1.无需在每个业务模块编写审批相关代码，将审批操作、任务列表相关的操作收集到一处。

2.审批相关数据无需与业务数据混杂。

3.审批新增功能时无需回归业务模块。

## 3.4与用户体系集成

流程运行本身不需要用户体系，但审批流的概念就是用户发起流程、用户进行审批，所以审批流需要与用户体系集成。

同时为了尽量减少两个系统间的耦合，审批流大多数时候都只需要用户的唯一标识，业务方根据用户唯一标识获取该用户与审批流相关的数据。

例外的是，在记录操作记录、推送消息时可能会需要用户昵称。

与用户体系集成，就有以下概念需要梳理：

### 3.4.1交互的方式

审批流本身需要的是一个【List】类型的用户id列表，数据来源有推拉之分。

1.业务方主动调用审批流api设置审批人列表。

业务场景：某些节点的审批人是由用户在界面上操作后得出的、某些节点的审批人是业务表单里填写的。

此种方式业务代码需要关心审批流节点的id，存在一定耦合，但贴合业务。

2.业务方在设计流程模型的时候定义好规则，并预先埋下一些数据，审批流在合适的时机回调业务方的方法并透传这些数据，业务方需要根据数据返回审批人列表。

业务场景：定义好的通用规则足够覆盖获取审批人的逻辑，如根据部门选人等。

此种方式基本把审批流和业务接耦，但没法为业务做定制化。

### 3.4.2审批用户的分类

审批用户的定义多种多样，就是用于圈定一批用户的规则，根据需要可自己随便定义。

如发起人、根据部门选用户、根据角色选用户、根据岗位选用户、指定用户、发起人一级上级等定义。

### 3.4.3设置某节点审批用户的时机（业务方主动）

模型创建时设置：在设计流程模型的时候写死该节点的审批人。所有使用该流程模型发起的流程实例该节点的审批人都是一样的。

流程启动时设置：流程发起时直接指定某节点的审批人。

节点开始之前设置：监听到某个用户任务节点开始消息后，设置该节点的审批人。

流程中节点之前任意位置设置：根据需要，在某个用户任务节点开始之前的任意时机设置。业务场景：xx节点需指定下一节点审批人。

### 3.4.4审批流获取某节点审批用户的时机（审批流主动）

流程启动时获取：流程发起时就调用业务方方法获取某个节点的审批人。

节点开始获取：在对应的用户任务节点开始前，获取该用户任务节点的审批人。

不获取：审批流自己不主动获取，等待业务方主动推送。

## 3.5提供扩展点

有一些流程本身不关心也不需要，但业务需要的数据。

有一些流程在运行过程中，业务可能想要进行自定义操作的时机点。

审批流二方包使用spring的发布订阅机制，对这些逻辑进行了实现，如：

1.待办、抄送、催办等消息的推送

应用场景：业务自实现推送方式：钉钉、邮件、站内信等。

2.流程节点开始、流程节点结束的通知

应用场景：节点开始前设置该节点审批人。节点结束后设置流程变量，某些流程变量涉及到流程的走向，为了保证实时性，需在前置节点结束后设置。

3.流程结束通知

应用场景：流程审批结束，业务方根据审批结果（通过、取消、拒绝），可自行实现业务逻辑。

## 3.6动态表单的概念

在将审批流模块独立出来后，审批相关的任务详情界面只有一个，但不同的人在不同的时机（流程模型、流程节点）需要看到的界面不同，需要填写的数据也不同

业务场景：

1.xx流程xx节点审批人需维护xx业务数据（在审批时操作），并将数据回写到业务数据中。

2.xx流程xx节点审批人需要关注一些特殊信息，需要在他审批时让他能清晰的看到这些数据，而其他流程或其他节点的审批人则不需要看到这些数据。

实现方式：

1.（目前使用的方式）与前端约定表单标识，前端写死模块（表单数量相对固定）（工作量较少，但每次新增表单需要写死代码）

2.表单设计器方式，用json描述界面布局、表单样式、表单数据等（动态灵活，但比较复杂，实际上可以拓展为一个新的服务）

# 4.其他

## 4.1技术文档

也可以看看[审批流技术方案设计](http://wiki.zswltech.cn:8888/pages/viewpage.action?pageId=2823946)，但因实际实现中遇到的问题及需求的变动，实际实现方案已与文档有一定出入。

## 4.2工作流（业务流）

### 4.2.1与审批流的区别

审批流更贴近用户，需要用户操作来促进流程流转，流程的设计界面也应该更人性化，让没有编程基础的人也能使用整套审批流的功能。

业务流更贴近代码开发人员，过程中大多数节点是代码自动化执行，流程设计时可能还需要填写一些脚本，更底层更灵活更专业。

### 4.2.2一些节点

脚本任务：执行shell、groovy等脚本的节点，灵活的编写代码逻辑。

服务任务：指向一个java类，类里的逻辑可自己随便写，一般用来实现自定义节点，如http调用、rpc调用、业务逻辑操作等等都可用该节点进行二次定义。

业务规则任务：使用drools规则引擎。流程中有些地方的走向需要根据规则和变量判断，但规则和变量的计算一般是写死在代码里的，如需修改就要重新发布模型或修改代码。使用业务规则任务替换drools脚本可以热更新规则和变量的计算方式。

信号开始事件：接收到信号后触发流程，信号可以由其他流程丢出。

定时开始事件：设计定时规则，根据规则定时发起流程。

信号中间事件：流程到该节点后停留，直到接收到一个信号后继续流转。

定时边界事件：挂载在某任务节点上，并通过顺序流指向另一节点，该任务节点执行超时后触发边界事件，流程走向边界事件指向的节点。